<!doctype html>
<html class="no-js" lang="">

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="style.css">
    <title></title>

</head>
<body>
<script src="index.js"></script>
<h1>1. HTML/CSS</h1>

<h2>1.1.Блочные и строчные элементы</h2>

<ul>1. Блочные и строчные элементы в HTML (Display: block, inline-block, inline)
    <li>Display: block - Блочные элементы занимают всю ширину своего родителя (контейнера), формально создавая «блок»
    </li>
    <li>Display: inline - Строчный элемент не начинается с новой строки и в ширину занимает столько места, сколько это
        необходимо для его
        отображения.
    </li>
    <li>Display: inline-block - Блочно-строчный означает элемент, который продолжает находиться в строке (inline), но
        при этом может иметь
        важные свойства блока.
    </li>
</ul>

<ul>2. Можно ли задать строчным элементам width и height?
    <li>Нет, только если изменен display</li>
</ul>

<ul>3. Может ли блочный элемент быть в строчном?
    <li>Нет, браузер вынесет блочный элемент из строчного</li>
</ul>

<h2>1.2 HTML Разметка</h2>

<ul>1. Слышали о семантичной разметке? Что это? Как считаете, для чего она нужна?
    <li>Семантическая вёрстка — подход к разметке, который опирается не на содержание сайта, а на смысловое
        предназначение каждого блока и логическую структуру документа. Даже в этой статье есть заголовки разных уровней
        — это помогает читателю выстроить в голове структуру документа. Так и на странице сайта — только читатели будут
        немного другими.
        Нужна для доступности сайта для особенных людей, для поисковиков
    </li>
</ul>

<ul>2. В чём отличие тегов b и strong?
    <li>b- выделение визуально полужирным шрифтом, strong – выделение полужирным шрифтом и указание важности</li>
</ul>

<ul>3. Можно ли делать активные элементы страницы на div блоках? Какие есть недостатки у данного подхода?</ul>

<ul>4. Вам знакомы единицы измерения vh и vw?</ul>

<ul>5. Что задает свойство box-sizing?
    <li>Свойство box-sizing может принимать одно из двух значений – border-box или content-box. В зависимости от
        выбранного значения браузер по-разному трактует значение свойств width/height.
        Значения box-sizing
        content-box
        Это значение по умолчанию. В этом случае свойства width/height обозначают то, что находится внутри padding.
        border-box
        Значения width/height задают высоту/ширину всего элемента.
    </li>
</ul>

<h2>1.3 Браузерные стили</h2>

<ul>1. Одинаковые ли стили у разных браузеров?
    <li>Нет, каждый браузер может иметь свои стили для тегов по умолчанию (user agent stylesheet)</li>
</ul>

<ul>2. Как избавиться от этой проблемы?
    <li>Дефолтные стили браузера можно переопределить и нормализовать. Для того чтобы нормализовать стили, которые
        отличаются в разных браузерах можно использовать Normalize.css
    </li>
</ul>

<h2>1.4 CSS Вес селекторов</h2>

<ul>1. Какой CSS селектор самый тяжелый?
    <li>Через атрибут style="" (inline), следующий #id, классы и псевдоклассы, элементы и псевдоэлементы.</li>
</ul>

<ul>2. Какого цвета бэкграунд будет в нашем диве?
    <li>
        <html>
        <head>
            <title></title>
            <style>
                #wrap div {
                    background-color: green;
                }

                #box {
                    background-color: red;
                }
            </style>
        </head>
        <body>
        <div id="wrap">
            <div id="box">Hello World!</div>
        </div>
        </body>
        </html>
        Ответ: Наш див будет зеленым
    </li>
</ul>

<ul>3. Как можно переопределить CSS свойство самого тяжелого селектора?
    <li>Переопределить стили, заданные в style, можно дописав !important к значению свойства в таблице стилей.</li>
</ul>

<ul>4. Часто ли приходилось использовать !important?
    <li>Если да, то почему? Часто использование !important говорит о плохой организации стилей и верстки разработчиком
    </li>
</ul>

<ul>5. Как определить приоритетность css селекторов?</ul>

<h2>1.5 CSS Позиционирование</h2>

<ul>1. В чём отличие visibility: hidden и display: none?
    <li>visibility: hidden скрывает элемент от просмотра, но не от потока страницы, оставляя место для него на странице.
        display: none удаляет элемент со страницы полностью, и страница создается так, как если бы элемент вообще
        отсутствовал.
    </li>
</ul>

<ul>2. Что задаёт свойство flex-grow?
    <li>flex-grow определяет как много свободного пространства во flex-контейнере должно быть назначено текущему
        элементу. Свободное пространство — разница между размером flex-контейнера и размером всех его flex-элементов
        вместе. Если все элементы имеют одинаковый коэффициент flex-grow, то все они получат одинаковую долю свободного
        пространства, в противном случае оно распределяется в соответствии с соотношением, определённым различными
        коэффициентами flex-grow.
    </li>
</ul>

<ul>3. Как отцентровать элемент по вертикали?</ul>

<ul>4. Что задаёт свойство z-index?
    <li>Свойство z-index определяет положение элемента и нижестоящих элементов по оси z. В случае перекрытия элементов,
        это значение определяет порядок наложения. В общем случае, элементы с большим z-index перекрывают элементы с
        меньшим.
    </li>
</ul>

<ul>5. Расскажите о свойстве Position: static, relative, absolute, fixed, sticky</ul>

<h2>1.6 CSS Медиа-запросы</h2>

<ul>1. Что такое медиа-запросы в CSS и как они помогают реализовывать адаптивную верстку?
    <li></li>
</ul>
<ul>2. Что такое псевдоклассы?
    <li>Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние.
    </li>
</ul>
<h2>1.7 CSS Псевдоклассы</h2>
<ul>1. псевдоклассы :hover, :focus, :active и псевдоэлементах ::after, ::before
    <li>Псевдокласс hover срабатывает в момент наведения курсора мыши на элемент.</li>
    <li>Псевдокласс focus применяется когда человек взаимодействует с элементом форм (form) такими как input, textarea,
        select, button и ссылки. Активируется при клике мышью пользователем по элементу или при выборе элемента с
        использованием клавиши "tab" на клавиатуре. При фокусе на элементе появляется обводка (outline) по умолчанию
    </li>
    <li>Псевдокласс active срабатывает в момент нажатия левой кнопки мыши на элемент.</li>
    <li>::after создает псевдоэлемент, который является последним потомком элемента.</li>
    <li>::before создает псевдоэлемент, который является первым потомком элемента.</li>
</ul>
<h2>1.8 CSS Препроцессоры</h2>
<ul>1. Какие препроцессоры вы знаете? Какие преимущества дают препроцессоры?
    <li></li>
</ul>
<h2>1.9 Принцип работы браузера</h2>
<ul>1. Что такое DOM?
    <li>Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы
        в виде объектов, которые можно менять.
    </li>
</ul>
<ul>2. Что такое BOM?
    <li>Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером
        (окружением), чтобы работать со всем, кроме документа.
    </li>
</ul>
<ul>3. Что такое repaint и когда он срабатывает?
    <li>Repaint - в случае изменения стилей элемента, не влияющих на его размеры и положение на странице (например,
        background-color, border-color, visibility), браузер просто отрисовывает его заново, с учётом нового стиля —
        происходит repaint (или restyle).
    </li>
</ul>
<ul>4. Что такое reflow и когда он срабатывает?
    <li>Reflow (или relayout) - вызывается в случае если изменения затрагивают содержимое, структуру документа,
        положение элементов. Причинами таких изменений обычно являются:
        <ul>
            <li>Манипуляции с DOM (добавление, удаление, изменение, перестановка элементов);</li>
            <li>Изменение содержимого, в т.ч. текста в полях форм;</li>
            <li>Расчёт или изменение CSS-свойств;</li>
            <li>Добавление, удаление таблиц стилей;</li>
            <li>Манипуляции с атрибутом «class»;</li>
            <li>Манипуляции с окном браузера — изменения размеров, прокрутка;</li>
            <li>Активация псевдо-классов (например, :hover).</li>
        </ul>
    </li>
</ul>
<h1>2. Java Script</h1>
<h2>2.1 Типы данных</h2>
<ul>1. Какие типы данных вы знаете? В JavaScript есть 8 основных типов.
    <li>number для любых чисел: целочисленных или чисел с плавающей точкой</li>
    <li>bigint для целых чисел произвольной длины. (новый)</li>
    <li>string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.</li>
    <li>boolean для true/false.</li>
    <li>null для неизвестных значений – отдельный тип, имеющий одно значение null.</li>
    <li>undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.</li>
    <li>object для более сложных структур данных.</li>
    <li>symbol для уникальных идентификаторов.</li>
</ul>
<ul>2. Что выведет "typeof null" и почему?
    <li>"object" – это ошибка в языке, на самом деле это не объект.</li>
</ul>
<ul>3. Как проверить, является ли значение null?
    <li>Для проверки нужно использовать оператор строгого равенства «===»
        const isNull = (value) => value === null
    </li>
</ul>
<ul>4. Почему это не исправят в новых версиях?
    <li>Для сохранения совместимости со старым кодом</li>
</ul>
<ul>5. Что выведет "NaN === NaN"?
    <li>"false" - NaN является неравным (посредством сравнения через ==, !=, ===, and !==) любому другому значению,
        включая другое значение NaN.
    </li>
</ul>
<ul>6. 0.1 + 0.2 === 0.3
    <li>"false" - известная проблема представления дробных чисел в ЯП</li>
</ul>
<ul>7. [] + {}
    <li>'[object Object]' - плюс действует как простой оператор конкатенации. Чтобы сложить пустой массив и пустой
        объект, он приводит их к строковому представлению.
    </li>
</ul>
<ul>8. {} + []
    <li>'0' - Фигурные скобки в начале он принимает за отдельно стоящий блок инструкций, пустой блок, поэтому игнорирует
        его. Остается лишь часть + []. Здесь плюс является простым унарным оператором, который неявно приводит значение
        к числу. Пустой массив приводится к нулю.
    </li>
</ul>
<h2>2.2 Массивы</h2>
<ul>1. Если мы воспользуемся оператором typeof на массиве, что он выведет?
    <li>object</li>
</ul>
<ul>2. Какие методы добавления/удаления элемента массива вы знаете?
    <li>.push()/.pop() и .unshift()/.shift()</li>
</ul>
<ul>3. Какой из этих методов быстрее и почему?
    <li>push/pop быстрее потому что работают с элементами в конце массива, а unshift/shift с его началом и для этих
        операций требуется переиндексация всего массива
    </li>
</ul>
<ul>4. Что если использовать вместо pop/shift/splice delete?
    <li>На месте удаленных элементов останется undefined</li>
</ul>
<ul>5. Какие методы работы с массивами ещё знаете?
    <li></li>
</ul>
<ul>6. Какая проблема в этом коде? Как бы улучшили? ответ .reduce()
    <li>const wizards = [
        {
        name: 'Harry Potter',
        house: 'Gryfindor'
        },
        {
        name: 'Cedric Diggory',
        house: 'Hufflepuff'
        },
        {
        name: 'Tonks',
        house: 'Hufflepuff'
        },
        {
        name: 'Ronald Weasley',
        house: 'Gryfindor'
        },
        {
        name: 'Hermione Granger',
        house: 'Gryfindor'
        }];

        const hufflepuff = wizards.filter(function (wizard) {
        return wizard.house === 'Hufflepuff';
        }).map(function (wizard) {
        return wizard.name;
        });
    </li>
</ul>
<h2>2.3 Объекты</h2>
<ul>1. Для чего используется ключевое слово «new»
    <li>Ключевое слово «new» используется в функциях-конструкторах для создания нового объекта (нового экземпляра
        класса).
        Когда функция вызывается как new User(...), происходит следующее:
        <ul>
            <li>Создаётся новый пустой объект, и он присваивается this.</li>
            <li>Выполняется код функции. Обычно он модифицирует this, добавляет туда новые свойства.</li>
            <li>Возвращается значение this.</li>
        </ul>
        Другими словами, вызов new User(...) делает примерно вот что
        function User(name) {
        // this = {}; (неявно)

        // добавляет свойства к this
        this.name = name;
        this.isAdmin = false;

        // return this; (неявно)
        }
    </li>
</ul>
<ul>2. Что такое объект Set?
    <li>Объект Set позволяет хранить уникальные значения, примитивы и ссылки на объекты. Еще раз: в Set можно добавлять
        только уникальные значения. Он проверяет хранящиеся в нем значения с помощью алгоритма SameZeroValue.
        Экземпляр Set создается с помощью конструктора Set. Мы также можем передать ему некоторые значения при создании:
        const set1 = new Set()
        const set2 = new Set(['a','b','c','d','d','e']) // вторая "d" не добавится
        Мы можем добавлять значения в Set, используя метод add. Поскольку метод add является возвращаемым, мы может
        использовать цепочку вызовов:
        set2.add('f')
        set2.add('g').add('h').add('i').add('j').add('k').add('k') // вторая "k" не добавится
        Мы можем удалять значения из Set, используя метод delete:
        set2.delete('k') // true
        set2.delete('z') // false, потому что в set2 нет такого значения
        Мы можем проверить наличие свойства в Set, используя метод has:
        set2.has('a') // true
        set2.has('z') // false
        Для получения длины Set используется метод size:
        set2.size // 10
        Метод clear очищает Set:
        set2.clear() // пусто
        Мы можем использовать Set для удаления повторяющихся значений в массиве:
        const nums = [1,2,3,4,5,6,6,7,8,8,5]
        const uniqNums = [...new Set(nums)] // [1,2,3,4,5,6,7,8]
    </li>
</ul>
<ul>3. Что такое объектная обертка (Wrapper Objects)?
    <li>Примитивы строка, число и boolean имеют свойства и методы, несмотря на то, что они не являются объектами:
        let name = 'marko'

        console.log(typeof name) // string
        console.log(name.toUpperCase()) // MARKO
        Name — это строка (примитивный тип), у которого нет свойств и методов, но когда мы вызываем метод toUpperCase(),
        это приводит не к ошибке, а к «MARKO».
        Причина такого поведения заключается в том, что name временно преобразуется в объект. У каждого примитива, кроме
        null и undefined, есть объект-обертка. Такими объектами являются String, Number, Boolean, Symbol и BigInt. В
        нашем случае код принимает следующий вид:
        console.log(new String(name).toUpperCase()) // MARKO
        Временный объект отбрасывается по завершении работы со свойством или методом.
    </li>
</ul>
<ul>4. Что такое Object.freeze?
    <li>Метод Object.freeze() замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту,
        удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости,
        настраиваемости и записываемости. В сущности, объект становится эффективно неизменным. Метод возвращает
        замороженный объект.
    </li>
</ul>
<ul>5. Что такое Object.seal?
    <li>Метод Object.seal() запечатывает объект, предотвращая добавление новых свойств к объекту и делая все
        существующие свойства не настраиваемыми. Значения представленных свойств всё ещё могут изменяться, поскольку они
        остаются записываемыми
    </li>
</ul>
<ul>6. В чем разница между методами Object.freeze и Object.seal?
    <li>Разница заключается в том, что при использовании метода Object.freeze мы не можем менять или редактировать
        свойства объекта, а при использовании Object.seal у нас такая возможность имеется
    </li>
</ul>
<h2>2.4 Операторы</h2>
<ul>1. Назовите разницу между операторами «=», «==» и «===»
    <li>= оператор присвоения</li>
    <li>== является не строгим сравнением (Приравнивает типы данных к 1 виду)</li>
    <li>=== строгое сравнение данных (Не приравнивает типы данных)</li>
</ul>
<ul>2. Имеем ли мы доступ к переменным a и b вне функции myFunc? Пример
    <li>function myFunc(){
        let a = b = 10;
        console.log('myFunc -> a', a);
        console.log('myFunc -> b', b);
        }
        myFunc();
        console.log('global-> a', a);
        console.log('global -> b', b);
        С выводом а будет ReferenceError, но если мы выведем только b, то переменная будет доступна.
        Так происходит, потому что оператор присваивания ("=") имеет правостороннюю ассоциативность, т.е. присваивает
        значения справа налево. Поэтому код принимает следующий вид:
        function myFunc(){
        let a = (b = 0);
        }
        myFunc();
        Сначала значение 0 присваивается переменной «b», которая не объявлена. Движок JS делает ее глобальной.
        Возвращаемое выражением b = 0 значение (0) затем присваивается локальной переменной «a».
        Эту проблему можно решить сначала объявив локальные переменные, а затем присвоив им значения:
        function myFunc(){
        let a, b;
        a = b = 0;
        }
        myFunc();
    </li>
</ul>
<ul>3. Для чего используется оператор "!!"?
    <li>Оператор "!!" (двойное отрицание) приводит значение справа от него к логическому значению.</li>
</ul>
<h2>2.5 Рекурсия</h2>
<ul>1. Что такое рекурсия?
    <li>Рекурсия — это когда функция вызывает сама себя.
        ПРИМЕР РЕКУРСИИ факториал числа
        Факториал
        function factorial(x) {
        if (x < 0) return;
        if (x === 0) return 1;
        return x * factorial(x - 1);
        }
        factorial(3); // 6
        factorial(4); // 24
    </li>
</ul>
<h2>2.6 Hoisting (Поднятие)</h2>
<ul>1. Расскажите о Hoisting (Поднятии) в JavaScript
    <li></li>
</ul>
<h2>2.7 function expression / function declaration</h2>
<ul>1. Что такое function expression (функциональное выражение) и function declaration (объявление функции) и чем они
    отличаются?
    <li></li>
</ul>
<ul>2. В чём особенность стрелочной функции?
    <li></li>
</ul>
<h2>2.8 Области видимости</h2>
<ul>1. Области видимости
    <li>Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа
        областей видимости: глобальная, функциональная и блочная (ES6).
        Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют
        глобальную область видимости и доступны из любого места в коде.
        Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные
        внутри функции, доступны только внутри этой функции.
        Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }),
        доступны только внутри него.
        Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не
        существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области
        видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до
        глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается,
        если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и
        останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).
    </li>
</ul>
<h2>2.9 Замыкания</h2>
<ul>1. Что такое замыкание?
    <li>По сути, замыкание — это способность функции во время создания запоминать ссылки на переменные и параметры,
        находящиеся в текущей области видимости, в области видимости родительской функции, в области видимости родителя
        родительской функции и так до глобальной области видимости с помощью цепочки областей видимости. Обычно область
        видимости определяется при создании функции.
    </li>
</ul>
<ul>2. Что выведет данный код?
    <li>const arrFunc = []
        for (var i = 0; i < 5; i++) {
        arrFunc.push(function() {
        return i
        })
        }

        for (let i = 0; i < arrFunc.length; i++) {
        console.log(arrFunc[i]())
        }
        Выведет все 5ки
    </li>
</ul>
<ul>3. Как исправить?
    <li>IIFE или let</li>
</ul>
<ul>4. Что выведет данный код?
    <li>function main() {
        var a = 100;
        function foo() {
        var b = a + 50;

        return b;
        }

        function bar() {
        var a = 40;

        return foo();
        }

        function baz() {
        return foo() + bar();
        }

        return baz();
        }

        console.log(main());
        300
    </li>
</ul>
<h2>2.10 Окружение</h2>
<ul>1. Что такое this?
    <li></li>
</ul>
<ul>2. Как изменить контекст?
    <li></li>
</ul>
<h2>2.11 Наследование</h2>
<ul>1. Что такое наследование?
    <li></li>
</ul>
<h2>2.12 Event loop</h2>
<ul>1. Что такое event loop и call stack?
    <li></li>
</ul>
<ul>2. Что такое макрозадачи и микрозадачи?
    <li></li>
</ul>
<h2>2.13 Асинхронщина</h2>
<ul>1. Что такое промисы?
    <li>Промисы — это один из приемов работы с асинхронным кодом в JS. Они возвращают результат асинхронной операции.
        Промисы были придуманы для решения проблемы так называемого «ада функций обратного вызова».
        У промиса есть четыре состояния:
        <ul>
            <li>Ожидание — начальное состояние промиса. Результата промиса неизвестен, поскольку операция не
                завершена.
            </li>
            <li>Выполнено — асинхронная операция выполнена, имеется результат.</li>
            <li>Отклонено — асинхронная операция не выполнена, имеется причина.</li>
            <li>Завершено — выполнено или отклонено.</li>
        </ul>
    </li>
</ul>
<ul>2. Что такое async/await?
    <li>Async/await — относительно новый способ написания асинхронного (неблокирующего) кода в JS. Им оборачивают
        промис. Он делает код более читаемым и чистым, чем промисы и функции обратного вызова. Однако для использования
        async/await необходимо хорошо знать промисы.
    </li>
</ul>
<h2>2.14 Event</h2>
<ul>1. Что такое делегирование событий?
    <li></li>
</ul>
<ul>2. Что такое распространение события (Event Propagation)?
    <li>Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие
        «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно
        пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:
        <ul>
            <li>Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события
                через всех ее предков.
            </li>
            <li>Целевая фаза — это когда событие достигает целевого элемента.</li>
            <li>Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и
                достигает объекта Window.
            </li>
        </ul>
    </li>
</ul>
<ul>3. Что такое всплытие события?
    <li>Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно
        пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем
        поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window.
    </li>
</ul>
<ul>4. Что такое погружение события?
    <li>Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от
        объекта Window до цели события через всех его предков.
    </li>
</ul>
<ul>5. В чем разница между методами event.preventDefault() и event.stopPropagation()?
    <li>Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе
        form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет
        отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании
        музыкального/видео плеера или текстового редактора — прим. пер.). Метод event.stopPropagation() отключает
        распространение события (его всплытие или погружение).
    </li>
</ul>
<ul>6. Как узнать об использовании метода event.preventDefault()?
    <li>Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее
        индикатором применения к элементу метода event.preventDefault.
    </li>
</ul>
<h2>2.15 Prototype</h2>
<ul>1. Что такое прототип объекта?
    <li>В двух словах, прототип — это план (схема или проект) объекта. Он используется как запасной вариант для свойств
        и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между
        объектами. Это основная концепция прототипного наследования в JS.
    </li>
</ul>
<ul>2. Как создать объект, не имеющий прототипа?
    <li>Это можно сделать с помощью Object.create:
        const o1 = {}
        console.log(o1.toString) // [object Object]

        const o2 = Object.create(null) // в качестве первого параметра методу Object-create передается объект-прототип
        // нам не нужен объект-прототип, поэтому передаем null
        console.log(o2.toString) // o2.toString is not a function
    </li>
</ul>
<ul>3. В чем разница между null и undefined?
    <li>null — это «значение отсутствия значения». null — это значение, которое присваивается переменной явно.

        undefined («неопределенный») представляет собой значение по умолчанию:
        <ul>
            <li>переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;
            </li>
            <li>функции, которая ничего не возвращает явно, например, console.log(1);</li>
            <li>несуществующего свойства объекта.</li>
        </ul>
    </li>
</ul>
<h2>2.16 Rest & Spread операторы</h2>
<ul>1. В чем разница между spread-оператором и rest-оператором?
    <li>Операторы spread и rest имеют одинаковый синтаксис ("..."). Разница состоит в том, что с помощью spread мы
        передаем или распространяем данные массива на другие данные, а с помощью rest — получаем все параметры функции и
        помещаем их в массив (или извлекаем часть параметров).
    </li>
</ul>
<h2>2.17 Деструктуризация</h2>
<ul>1. Что такое деструктуризация объекта (Object Destructuring)?
    <li>Деструктуризация — относительно новый способ получения (извлечения) значений объекта или массива.
        Использование деструктуризации позволяет сделать код чище и отнимает меньше времени. Синтаксис деструктуризации
        следующий: заключаем свойства объекта, которые хотим получить, в фигурные скобки ({ }), а если речь идет о
        массиве — в квадратные скобки ([ ])
    </li>
</ul>
<h2>2.18 Network</h2>
<ul>1. В чём различие get и post запросов?
    <li></li>
</ul>
<h1>3 React</h1>
<ul>1. Что такое React?
    <li>React — это библиотека JavaScript с открытым исходным кодом, созданная Facebook для разработки сложных
        интерактивных пользовательских интерфейсов в веб- и мобильных приложениях. Основная цель React — создание
        компонентов пользовательского интерфейса; их часто называют просто «V» (View) в архитектуре «MVC».
    </li>
</ul>
<ul>2. Что такое Виртуальная DOM?
    <li>Виртуальная DOM является представлением реальной DOM в памяти. React создает кэш структуры данных в памяти,
        вычисляет результирующие различия и затем эффективно обновляет отображаемую DOM браузера (ReactDOM). Это
        позволяет программисту писать код, как будто вся страница отображается при каждом изменении, в то время как
        библиотеки React отображают только те подкомпоненты, которые действительно изменяются.
        Порядок обновления:
        <ul>
            <li>Каждый раз когда какие-либо данные изменяются, весь пользовательский интерфейс перерисовывается в
                виртуальном DOM
            </li>
            <li>Далее вычисляется разница между предыдущим представлением DOM и новым.</li>
            <li>После вычисления будет обновлён реальный DOM, только те вещи которые действительно изменились.</li>
        </ul>
    </li>
</ul>
<ul>3.Что такое Props?
    <li>Props это короткое название Properties в React. Они только для чтения. Они всегда передаются вниз от родителя к
        ребёнку. Дочерний компонент никогда не может передать prop обратно родителю. Это помогает поддерживать
        однонаправленный поток данных и обычно используется для рендера динамически генерируемых данных.
    </li>
</ul>
<ul>4. Что такое состояние в React?
    <li>Состояние похоже на свойство, но оно является частным и полностью контролируется компонентом. State — это
        обязательно объект, который содержит данные и определяет, как компонент отображается и ведет себя. По сути state
        - это объекты которые определяют рендеринг и поведение компонентов. Он мутабельный в отличии от props и создают
        динамические и интерактивные компоненты.
    </li>
</ul>
<ul>5. Какие существуют фазы жизненного цикла компонентов React?
    <li>Существует четыре различных этапа жизненного цикла компонента React:
        <ul>
            <li> Инициализация: На этом этапе компонент React готовит установку начального состояния и параметров по
                умолчанию.
            </li>
            <li> Монтирование: Компонент React готов для монтирования в DOM браузера. Этот этап охватывает методы
                жизненного цикла componentWillMount и componentDidMount.
            </li>
            <li> Обновление: На этом этапе компонент обновляется двумя способами, отправляя новые свойства и обновляя
                состояние. Этот этап охватывает методы жизненного цикла shouldComponentUpdate, componentWillUpdate и
                componentDidUpdate.
            </li>
            <li> Размонтирование: На этом последнем этапе компонент не нужен и отключается из DOM браузера. Этот этап
                включает метод жизненного цикла componentWillUnmount.
            </li>
        </ul>
    </li>
</ul>
<ul>6. Что такое JSX?
    <li>JSX является расширением синтаксиса JavaScript и поставляется с полной функциональностью JavaScript. JSX производит «элементы» React. Вы можете встроить любое выражение JavaScript в JSX, заключив его в фигурные скобки. После компиляции выражения JSX становятся обычными объектами JavaScript. Это означает, что вы можете использовать JSX внутри операторов if и циклов for, назначать его переменным, принимать в качестве аргументов и возвращать из функций.</li>
</ul>
<ul>7. Что такое контролируемые компоненты?
    <li>В контролируемом компоненте данные формы обрабатываются состоянием внутри компонента. Состояние внутри компонента служит «единственным источником правды» для элементов ввода, которые отображаются компонентом.
        Нам не нужен элемент формы на странице, чтобы компонент был контролируемым компонентом.
    </li>
</ul>
<ul>8. Что такое некотролируемые компоненты?
    <li>Неконтролируемые компоненты действуют больше как традиционные элементы формы HTML. Данные для каждого элемента ввода хранятся в DOM, а не в компоненте. Вместо того, чтобы писать обработчик событий для всех ваших обновлений состояния, вы используете ref для получения значений из DOM.</li>
</ul>
<ul>9. Как вы понимаете под словом refs в React?
    <li>Refs это короткое название от References в React. Это атрибут, который помогает хранить ссылку на определенный элемент или компонент в React, который будет возвращен функцией конфигурации рендеринга компонентов. Используется для возврата ссылок на определенный элемент или компонент, возвращаемый render(). Они пригодятся, когда нам нужны изменения DOM или для добавления методов к компонентам.</li>
</ul>
<ul>10. Приведите пример когда следует использовать refs?
    <li>Когда нужно работать с фокусом, выделить текст или работа с медиа
        Для запуска императивной анимации (Императивная анимация работает в браузере основным потоком.)
        Для интеграции со сторонними библиотеками
    </li>
</ul>
<ul>11. Что такое компоненты высшего порядка?
    <li>Компоненты высшего порядка продвинутый путь переиспользования логики компонентов. По сути, это образец который вытекает из композиционной природы React. HOC это кастомный компонент который оборачивает другой компонент. Могут принять любой динамически предоставленный дочерний компонент, но они не будут изменять или копировать любое поведение из своих компонентов. Можно сказать что HOC это чистый компонент.</li>
</ul>
<ul>12. Что можно сделать с HOC?
    <li>Переиспользование кода, логики</li>
    <li>Абстракция и манипуляция state</li>
    <li>Манипуляция с props</li>

</ul>
<ul>13. Для чего нужны keys в React?
    <li>Ключи используются для идентификации уникальных виртуальных элементов DOM с соответствующими данными, управляющими пользовательским интерфейсом.Они помогают React оптимизировать рендеринг, перерабатывая все существующие элементы в DOM. Эти ключи должны быть уникальными числами или строками, используя которые React просто переупорядочить элементы, а не перерисовывает их.Это приводит к увеличению производительности приложения.</li>
</ul>
<ul>14. Что такое Context?
    <li>Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях.</li>
</ul>
<ul>15. Объясните Flux
    <li>Flux - это архитектурный паттерн, который обеспечивает однонаправленный поток данных. Он контролирует производные данные и обеспечивает связь между несколькими компонентами с использованием центрального хранилища, которые имеет полномочия для всех данных. Любое обновление данных должно происходить только здесь. Flux обеспечивает стабильность приложения и уменьшает ошибки во время выполнения.
    </li>
</ul>
<ul>16. Что такое Redux?
    <li>Это предсказуемый контейнер состояний для приложений JavaScript, который используется для управления состоянием всего приложения. Приложения, разработанные с помощью Redux, легко тестируются и могут работать в разных средах, демонстрируя согласованное поведение.
    </li>
</ul>
<ul>17. Три принципа которым следует Redux?
    <li>Единственный источник правды: Состояние всего приложения хранится в дереве объектов/состояний в одном хранилище. Единое дерево состояний облегчает отслеживание изменений и отладку или проверку приложения.</li>
    <li>State только для чтения: Единственный способ изменить state вызвать Action. Action - это просто объект JS описывающий изменение.</li>
    <li>Изменения сделаны чистыми функциями: Чтобы  указать, как дерево состояний трансформируется действиями, вам нужны чистые функции.</li>
</ul>
<ul>18. Как вы понимаете “Единый источник правды”?
    <li>Redux использует Store для хранения всего состояния приложения в одном месте. Таким образом все состояние компонента хранится в Store и они получают обновления от самого Store. Единое дерево состояний облегчает отслеживание изменений во времени и отладку или проверку приложения.</li>
</ul>
<ul>19. Назовите компоненты Redux?
    <li>Action - Объект который описывает что происходит</li>
    <li>Reducer - Место где определяется как state изменится</li>
    <li>Store - Состояние/Объект дерева всего приложения которое хранится в Store</li>
    <li>View - Отображает данные, предоставленные магазином</li>

</ul>
<ul>20. Как Actions определяются в Redux?
    <li>Action в React должны иметь свойство type которое показывает тип Action. Они должны быть определены как строковая константа, можно добавить еще свойства. В Redux actions создаются при помощи функции которая возвращает типа и данные.</li>
</ul>
<ul>21. Объясните роль Reducer?
    <li>Reducers это чистые функции которые описывают как состояние приложения изменяется в ответ на Action. Reducer работает принимая прежнее состояние и действие, а затем возвращает новое состояние. Он определяет, какое обновление необходимо выполнить, основываясь на типе действия, а затем возвращает новые значение. Возвращает предыдущее состояние если не нужно выполнять никаких действий.</li>
</ul>
<ul>22. Каково назначение Store в Redux?
    <li>Store - это JavaScript объект который содержит состояние приложения и предоставляет несколько вспомогательных методов для доступа к состоянию, рассылает действия и регистрирует слушателей. Все дерево состояний / объектов приложения сохраняется в одном хранилище. В результате Redux очень просто и предсказуем. Мы можем передать промежуточное программное обеспечение в хранилище для обработки данных, а также  для ведения журнала различных действий, которые изменяют состояние хранилищ. Все действия возвращают новое состояние через reducers.</li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>
<ul>
    <li></li>
</ul>


</body>
</html>
